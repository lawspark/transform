name: Create and publish a Docker image

on:
  # Allow manual re-runs (e.g. rebuild a historical tag)
  workflow_dispatch:
    inputs:
      ref:
        description: "Git ref to build (e.g. v0.4.0 or refs/tags/v0.4.0). If empty, uses the triggering ref."
        required: false
        type: string

  # Publish semver images on release publish (works even when tag push is created by workflows)
  release:
    types:
      - published

  # Publish latest on main, and also support tag pushes (when they come from a human/app token)
  push:
    branches:
      - main
    tags:
      - v*

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  build-and-push-image:
    runs-on: ubuntu-latest

    permissions:
      contents: read
      packages: write

    steps:
      - name: Resolve ref + tags
        id: vars
        shell: bash
        run: |
          set -euo pipefail

          REF_INPUT="${{ inputs.ref }}"
          REF="${REF_INPUT:-${GITHUB_REF}}"

          # Normalize to a checkout-able ref and a human tag name
          # Accept: refs/tags/v0.4.0, refs/heads/main, v0.4.0
          if [[ "$REF" == refs/tags/* ]]; then
            REF_NAME="${REF#refs/tags/}"
          elif [[ "$REF" == refs/heads/* ]]; then
            REF_NAME="${REF#refs/heads/}"
          else
            REF_NAME="$REF"
          fi

          IS_TAG=false
          if [[ "$REF" == refs/tags/* ]] || [[ "$REF_NAME" == v*.*.* ]]; then
            IS_TAG=true
          fi

          # Compute docker tags
          TAGS=()
          if [[ "$REF_NAME" == "main" ]]; then
            TAGS+=("${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest")
            VERSION="latest"
          elif [[ "$IS_TAG" == true ]]; then
            VERSION="$REF_NAME"   # keep the leading 'v'
            TAGS+=("${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION}")

            # Also publish vMAJOR.MINOR and vMAJOR convenience tags
            v=${VERSION#v}
            IFS='.' read -r MA MI PA <<<"$v"
            TAGS+=("${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${MA}.${MI}")
            if [[ "$MA" != "0" ]]; then
              TAGS+=("${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:v${MA}")
            fi
          else
            # Fallback for non-main branches: don't publish
            echo "Not main and not a tag; skipping." >&2
            echo "skip=true" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          # Output
          echo "ref=$REF" >> "$GITHUB_OUTPUT"
          echo "ref_name=$REF_NAME" >> "$GITHUB_OUTPUT"
          echo "version=$VERSION" >> "$GITHUB_OUTPUT"
          printf 'tags=%s\n' "$(IFS=,; echo "${TAGS[*]}")" >> "$GITHUB_OUTPUT"

      - name: Checkout sources
        if: ${{ steps.vars.outputs.skip != 'true' }}
        uses: actions/checkout@v4
        with:
          ref: ${{ steps.vars.outputs.ref }}

      - name: Setup Java
        uses: actions/setup-java@v4
        with:
          java-version: 21
          distribution: 'temurin'

      # NOTE: we intentionally avoid docker/metadata-action here.
      # Tag pushes created by workflows may not trigger other workflows.
      # We compute tags ourselves so manual dispatch can rebuild historical tags reliably.

      - name: Log in to the Container registry
        if: ${{ steps.vars.outputs.skip != 'true' }}
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup QEMU
        if: ${{ steps.vars.outputs.skip != 'true' }}
        uses: docker/setup-qemu-action@v3

      - name: Set up Docker Buildx
        if: ${{ steps.vars.outputs.skip != 'true' }}
        uses: docker/setup-buildx-action@v3

      - name: Build & Push
        if: ${{ steps.vars.outputs.skip != 'true' }}
        run: |
          DOCKER_IMAGE_TAGS="${{ steps.vars.outputs.tags }}"
          IMAGE_VERSION="${{ steps.vars.outputs.version }}"

          echo "Using tags: $DOCKER_IMAGE_TAGS"

          ./gradlew bootBuildImage \
            --imageName="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${IMAGE_VERSION}" \
            -PdockerImageTags="$DOCKER_IMAGE_TAGS" \
            --no-daemon

          docker images --format "{{ .Repository }}:{{ .Tag }}" \
            | grep ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }} \
            | xargs -L1 docker push
